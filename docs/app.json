[{"name":"app.R","content":"library(shiny)\nlibrary(shinydashboard)\nlibrary(DT)  # For interactive tables\nlibrary(readxl)\nlibrary(ggrepel)\nlibrary(dplyr, warn.conflicts=FALSE)\nlibrary(patchwork)\nlibrary(ggplot2, warn.conflicts=FALSE)\nlibrary(tidyverse, warn.conflicts=FALSE)\n# # Load in syntouch descriptors \n# source(\"../scripts/syntouch_measures_descriptions.R\")\n# \n# # Load code to generate radar plots\n# source(\"../scripts/coord_radar2.R\")\n\n# syntouch measures & description\n\nmeas_list <- tibble(\n  SyntouchVariable = c(\"aTK\",\n                       \"fRS\",\"fST\",\n                       \"mTX\",\"mCO\",\"mRG\",\n                       \"uCO\",\"uRO\",\n                       \"cCM\",\"cDF\",\"cDP\",\"cRX\",\"cYD\",\n                       \"tCO\",\"tPR\"),\n  Description = c(\"Adhesive Tack\",\n                  \"Sliding Resistance\",\"Tactile Stiction\",\n                  \"Macrotexture\",\"Macrotexture Coarseness\",\"Macrotexture Regularity\", \n                  \"Microtexture Coarseness\",\"Microtexture Roughness\",\n                  \"Tactile Compliance\",\"Local Deformation\",\"Damping\",\"Relaxation\",\"Yielding\",\n                  \"Thermal Cooling\",\"Thermal Persistance\"),\n  Grouping = c(\"Adhesion\",\n               \"Friction\",\"Friction\",\n               \"Texture\",\"Texture\",\"Texture\",\n               \"Texture\",\"Texture\",\n               \"Compliance\",\"Compliance\",\"Compliance\",\"Compliance\",\"Compliance\",\n               \"Thermal\",\"Thermal\"))\n\n\n# Define function to read CSV file\nread_file <- function(input) {\n  if (!is.null(input$file)) {\n    req(input$file)\n    read_excel(input$file$datapath, sheet = \"Sheet1\")\n  } else {\n    NULL\n  }\n}\n\n# Define function for data wrangling\ndata_wrangling <- function(df) {\n  df %>%\n    pivot_longer(cols = `Adhesive Tack`:`Yielding`,\n                 names_to = \"SynTouch Variable\", values_to = \"mean\") %>%\n    left_join(., meas_list, by = c(\"SynTouch Variable\" = \"Description\")) %>%\n    mutate(Sample = as.character(Sample))\n}\n\nrender_lollipop <- function(data,colvar) {\n  ggplot(data) +\n    geom_segment(aes(x = 0, xend = !!sym(colvar), y = reorder(`SynTouch Variable`, !!sym(colvar)),\n                     yend = reorder(`SynTouch Variable`, !!sym(colvar))), linewidth = 0.5) +\n    geom_point(aes(x = !!sym(colvar), y = reorder(`SynTouch Variable`, !!sym(colvar))),\n               shape = 21, fill = \"white\", colour = \"red\", size = 3) +\n    theme_minimal() +\n    geom_vline(xintercept = 0, linewidth = 0.5) +\n    annotate(\"rect\", fill = \"grey\", alpha = 0.4,\n             xmin = -5, xmax = 5,\n             ymin = -Inf, ymax = Inf) +\n    theme(text = element_text(family = \"Calibre\", size = 12),\n          strip.background = element_blank(),\n          panel.grid = element_line(linewidth = 0.15),\n          axis.text.x = element_text(size = 12),\n          axis.title.y = element_blank(),\n          legend.position = \"bottom\",\n          plot.margin = margin(0.5, 1, 0.5, 1, \"cm\"))\n}\n\ncoord_radar2 <- function (theta = \"x\", start = 0, direction = 1) \n{\n  theta <- match.arg(theta, c(\"x\", \"y\"))\n  r <- if (theta == \"x\") \n    \"y\"\n  else \"x\"\n  \n  #dirty\n  rename_data <- function(coord, data) {\n    if (coord$theta == \"y\") {\n      plyr::rename(data, c(\"y\" = \"theta\", \"x\" = \"r\"), warn_missing = FALSE)\n    } else {\n      plyr::rename(data, c(\"y\" = \"r\", \"x\" = \"theta\"), warn_missing = FALSE)\n    }\n  }\n  theta_rescale <- function(coord, x, scale_details) {\n    rotate <- function(x) (x + coord$start) %% (2 * pi) * coord$direction\n    rotate(scales::rescale(x, c(0, 2 * pi), scale_details$theta.range))\n  }\n  \n  r_rescale <- function(coord, x, scale_details) {\n    scales::rescale(x, c(0, 0.4), scale_details$r.range)\n  }\n  \n  ggproto(\"CordRadar\", CoordPolar, theta = theta, r = r, start = start, \n          direction = sign(direction),\n          is_linear = function(coord) TRUE,\n          render_bg = function(self, scale_details, theme) {\n            scale_details <- rename_data(self, scale_details)\n            \n            theta <- if (length(scale_details$theta.major) > 0)\n              theta_rescale(self, scale_details$theta.major, scale_details)\n            thetamin <- if (length(scale_details$theta.minor) > 0)\n              theta_rescale(self, scale_details$theta.minor, scale_details)\n            thetafine <- seq(0, 2 * pi, length.out = 100)\n            \n            rfine <- c(r_rescale(self, scale_details$r.major, scale_details))\n            \n            # This gets the proper theme element for theta and r grid lines:\n            #   panel.grid.major.x or .y\n            majortheta <- paste(\"panel.grid.major.\", self$theta, sep = \"\")\n            minortheta <- paste(\"panel.grid.minor.\", self$theta, sep = \"\")\n            majorr     <- paste(\"panel.grid.major.\", self$r,     sep = \"\")\n            \n            ggplot2:::ggname(\"grill\", grid::grobTree(\n              ggplot2:::element_render(theme, \"panel.background\"),\n              if (length(theta) > 0) ggplot2:::element_render(\n                theme, majortheta, name = \"angle\",\n                x = c(rbind(0, 0.45 * sin(theta))) + 0.5,\n                y = c(rbind(0, 0.45 * cos(theta))) + 0.5,\n                id.lengths = rep(2, length(theta)),\n                default.units = \"native\"\n              ),\n              if (length(thetamin) > 0) ggplot2:::element_render(\n                theme, minortheta, name = \"angle\",\n                x = c(rbind(0, 0.45 * sin(thetamin))) + 0.5,\n                y = c(rbind(0, 0.45 * cos(thetamin))) + 0.5,\n                id.lengths = rep(2, length(thetamin)),\n                default.units = \"native\"\n              ),\n              \n              ggplot2:::element_render(\n                theme, majorr, name = \"radius\",\n                x = rep(rfine, each = length(thetafine)) * sin(thetafine) + 0.5,\n                y = rep(rfine, each = length(thetafine)) * cos(thetafine) + 0.5,\n                id.lengths = rep(length(thetafine), length(rfine)),\n                default.units = \"native\"\n              )\n            ))\n          })\n}\n\nrender_radar <- function(data) {\n  ggplot(data) +\n    geom_polygon(aes(x = reorder(`SynTouch Variable`, id), y = mean, group = Sample,\n                     fill = Sample), colour = \"black\",\n                 linewidth = 0.15, alpha = 0.5) +\n    coord_radar2() +\n    scale_y_continuous(limits = c(0, 90)) +\n    theme_minimal() +\n    annotate('text', x = 0, y = c(10, 20, 30, 40, 50, 60, 70, 80, 90),\n             label = c(10, 20, 30, 40, 50, 60, 70, 80, 90),\n             size = 3.5, family = \"Calibre\") +\n    theme(text = element_text(family = \"Calibre\", size = 12),\n          strip.background = element_blank(),\n          panel.grid = element_line(linewidth = 0.15),\n          axis.title.x = element_blank(),\n          axis.text.y = element_blank(),\n          axis.text.x = element_text(size = 12),\n          axis.title.y = element_blank(),\n          legend.position = \"bottom\",\n          plot.margin = margin(0.5, 1, 0.5, 1, \"cm\"))\n}\n\n# Define UI for application that draws a histogram\n# Define UI\nui <- dashboardPage(\n  dashboardHeader(title = \"Syntouch Data Processing and Visualization\"),\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Data Wrangling\", tabName = \"data_wrangling\"),\n      menuItem(\"Single Fabric Visualization\", tabName = \"single_fabric\"),\n      menuItem(\"Head-to-Head Comparison\", tabName = \"head_to_head\")\n    )\n  ),\n  dashboardBody(\n    tabItems(\n      tabItem(tabName = \"data_wrangling\",\n              fluidRow(\n                # Add file input button to upload Excel file\n                fileInput(\"file\", \"Upload syntouch file\", accept = c(\".xls\", \".xlsx\"))\n              ),\n              fluidRow(\n                # Display data wrangling steps or interactive table here\n                DTOutput(\"data_table\")\n              )\n      ),\n      tabItem(tabName = \"single_fabric\",\n              fluidRow(\n                # Add UI components for single fabric visualization here\n                # Example: Lollipop plot\n                # Dropdown select input\n                selectInput(\"dropdown_single\", \"Select an option:\",\n                            \"\"),  # Placeholder for options, to be filled dynamically\n                textOutput(\"selected_option_single\"),\n                plotOutput(\"lollipop_plot_single\"),\n                plotOutput(\"radar_plot_single\"),\n                DTOutput(\"fabric_table_single\")\n              )\n      ),\n      tabItem(tabName = \"head_to_head\",\n              fluidRow(\n                selectInput(\"fabric_1\", \"Select reference fabric:\", choices = \"\"),\n                selectInput(\"fabric_2\", \"Select comparison fabric:\", choices = \"\"),\n                # Add UI components for head-to-head comparison here\n                # Example: Lollipop plot for head-to-head comparison\n                plotOutput(\"lollipop_plot_head2head\"),\n                # Example: Radar plot for head-to-head comparison\n                plotOutput(\"radar_plot_head2head\"),\n                DTOutput(\"fabric_table_head2head\")\n              )\n      )\n    )\n  )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output,session) {\n  # Read CSV file\n  df <- reactive(read_file(input))\n  \n  df_long <- reactive({\n    req(df())\n    data_wrangling(df())\n  })\n  \n  output$data_table <- renderDT({\n    # Render interactive table for data wrangling steps\n    datatable(df_long())\n  })\n  \n  # dropdown options in page 2\n  unique_values <- reactive({\n    req(df_long())\n    df_long() %>%\n      distinct(Sample) %>%\n      pull(Sample)\n  })\n  \n  # Update choices for dropdown select input\n  observe({\n    updateSelectInput(session, \"dropdown_single\", choices = unique_values())\n  })\n  \n  # Output selected option\n  output$selected_option <- renderText({\n    paste(\"You selected:\", input$dropdown_single)\n  })\n  \n  # filter raw data to isolate the selected fabric\n  fig_data <- reactive({\n    req(df_long())\n    df_long() %>%   \n      filter(Sample == input$dropdown_single) %>% \n      arrange(Grouping,\"SynTouch Variable\") %>% \n      group_by(Sample) %>% \n      mutate(id = row_number())\n  })\n  \n  # output the filtered data into a datatable for display\n  output$fabric_table_single <- renderDT({\n    # Render interactive table for data wrangling steps\n    datatable(fig_data())\n  })\n  \n  output$lollipop_plot_single <- renderPlot({\n    req(fig_data)\n    render_lollipop(fig_data(),\"mean\")\n  })\n  \n  output$radar_plot_single <- renderPlot({\n    req(fig_data)\n    render_radar(fig_data())\n  })\n  \n  # Head to head comparison function\n  # Update choices for dropdown select input\n  observe({\n    updateSelectInput(session, \"fabric_1\", choices = unique_values())\n  })\n  observe({\n    updateSelectInput(session, \"fabric_2\", choices = unique_values())\n  })\n  \n  # Reactive expression to check if both options are selected\n  both_options_selected <- reactive({\n    !is.null(input$fabric_1) && !is.null(input$fabric_2)\n  })\n  \n  filt_fabric <- reactive({\n    req(both_options_selected())\n    c(input$fabric_1,input$fabric_2)\n  })\n  \n  # filter raw data to isolate the selected fabric\n  comp_data <- reactive({\n    req(both_options_selected())\n    df_long() %>%\n      filter(Sample %in% filt_fabric()) %>%\n      arrange(Grouping,\"SynTouch Variable\") %>%\n      group_by(Sample) %>%\n      mutate(id = row_number())\n  })\n  \n  fig_dat_comp <- reactive({\n    req(both_options_selected())\n    comp_data() %>%\n      pivot_wider(names_from = \"Sample\",values_from = \"mean\")\n  })\n  \n  differences <- reactive({\n    req(both_options_selected())\n    fig_dat_comp() %>%\n      select(tail(colnames(.), 2)) %>%\n      mutate(diff = .[[2]] - .[[1]])\n  })\n  \n  col_names <- c(\"SyntouchVariable\",\"Grouping\",\"diff\")\n  combined_dat_comp <- reactive({\n    req(both_options_selected())\n    bind_cols(fig_dat_comp(), differences()) \n  })\n  \n  \n  output$lollipop_plot_head2head <- renderPlot({\n    req(both_options_selected())\n    render_lollipop(combined_dat_comp(),\"diff\")\n  })\n  \n  output$radar_plot_head2head <- renderPlot({\n    req(both_options_selected())\n    render_radar(comp_data())\n  })\n  \n  # \n  # output the filtered data into a datatable for display\n  output$fabric_table_head2head <- renderDT({\n    # Render interactive table for data wrangling steps\n    datatable(combined_dat_comp())\n  })\n  \n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"DESCRIPTION","content":"Title: Hello Shiny!\nAuthor: RStudio, Inc.\nAuthorUrl: http://www.rstudio.com/\nLicense: MIT\nDisplayMode: Showcase\nTags: getting-started\nType: Shiny\n","type":"text"},{"name":"Readme.md","content":"This small Shiny application demonstrates Shiny's automatic UI updates. \n\nMove the *Number of bins* slider and notice how the `renderPlot` expression is automatically re-evaluated when its dependant, `input$bins`, changes, causing a histogram with a new number of bins to be rendered.\n","type":"text"}]
